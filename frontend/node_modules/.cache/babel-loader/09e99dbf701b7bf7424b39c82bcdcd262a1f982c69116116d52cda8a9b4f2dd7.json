{"ast":null,"code":"var _DashboardWebSocketManager,\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { createWebSocket } from '../utils/api';\nimport { queryClient } from '../utils/api';\n\n// Global WebSocket manager for dashboard\nclass DashboardWebSocketManager {\n  constructor() {\n    this.ws = null;\n    this.listeners = new Map();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.isConnecting = false;\n    this.connect();\n  }\n  static getInstance() {\n    if (!DashboardWebSocketManager.instance) {\n      DashboardWebSocketManager.instance = new DashboardWebSocketManager();\n    }\n    return DashboardWebSocketManager.instance;\n  }\n  connect() {\n    if (this.isConnecting) return;\n    this.isConnecting = true;\n    try {\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      const host = window.location.hostname === 'localhost' ? 'localhost:8000' : window.location.host;\n      const url = `${protocol}//${host}/api/scans/ws/dashboard`;\n      console.log('Connecting to dashboard WebSocket:', url);\n      this.ws = new WebSocket(url);\n      this.ws.onopen = () => {\n        console.log('Dashboard WebSocket connected');\n        this.isConnecting = false;\n        this.reconnectAttempts = 0;\n        this.notifyListeners('connected', null);\n\n        // Start heartbeat\n        this.startHeartbeat();\n      };\n      this.ws.onmessage = event => {\n        try {\n          const message = JSON.parse(event.data);\n          console.log('Dashboard WebSocket message:', message);\n          this.notifyListeners('message', message);\n\n          // Handle specific events\n          if (message.type === 'dashboard_update') {\n            console.log('Dashboard update received, refreshing data...');\n\n            // Invalidate all dashboard-related queries\n            queryClient.invalidateQueries({\n              queryKey: ['dashboardMetrics']\n            });\n            queryClient.invalidateQueries({\n              queryKey: ['quickStats']\n            });\n            queryClient.invalidateQueries({\n              queryKey: ['reports']\n            });\n            queryClient.invalidateQueries({\n              queryKey: ['scans']\n            });\n\n            // Force refetch after a short delay\n            setTimeout(() => {\n              queryClient.refetchQueries({\n                queryKey: ['dashboardMetrics']\n              });\n              queryClient.refetchQueries({\n                queryKey: ['quickStats']\n              });\n            }, 100);\n            this.notifyListeners('dashboardUpdate', message);\n          }\n          if (message.type === 'scan_completed') {\n            console.log('Scan completed, updating dashboard...');\n            this.notifyListeners('scanCompleted', message);\n          }\n        } catch (error) {\n          console.error('Failed to parse dashboard WebSocket message:', error);\n        }\n      };\n      this.ws.onclose = () => {\n        console.log('Dashboard WebSocket disconnected');\n        this.isConnecting = false;\n        this.notifyListeners('disconnected', null);\n        this.attemptReconnect();\n      };\n      this.ws.onerror = error => {\n        console.error('Dashboard WebSocket error:', error);\n        this.isConnecting = false;\n        this.notifyListeners('error', error);\n      };\n    } catch (error) {\n      console.error('Failed to create dashboard WebSocket:', error);\n      this.isConnecting = false;\n      this.attemptReconnect();\n    }\n  }\n  startHeartbeat() {\n    // Send ping every 30 seconds to keep connection alive\n    const heartbeatInterval = setInterval(() => {\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify({\n          type: 'ping'\n        }));\n      } else {\n        clearInterval(heartbeatInterval);\n      }\n    }, 30000);\n  }\n  attemptReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);\n      console.log(`Attempting to reconnect dashboard WebSocket in ${delay}ms (attempt ${this.reconnectAttempts})`);\n      setTimeout(() => {\n        if (!this.isConnecting) {\n          this.connect();\n        }\n      }, delay);\n    } else {\n      console.error('Max reconnection attempts reached for dashboard WebSocket');\n    }\n  }\n  on(event, callback) {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, []);\n    }\n    this.listeners.get(event).push(callback);\n  }\n  off(event, callback) {\n    const listeners = this.listeners.get(event);\n    if (listeners) {\n      const index = listeners.indexOf(callback);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n  notifyListeners(event, data) {\n    const listeners = this.listeners.get(event);\n    if (listeners) {\n      // Use setTimeout to avoid React state updates during render\n      setTimeout(() => {\n        listeners.forEach(callback => {\n          try {\n            callback(data);\n          } catch (error) {\n            console.error('Error in dashboard WebSocket listener:', error);\n          }\n        });\n      }, 0);\n    }\n  }\n  send(message) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    }\n  }\n  getConnectionState() {\n    return this.ws ? this.ws.readyState : WebSocket.CLOSED;\n  }\n  isConnected() {\n    return this.ws && this.ws.readyState === WebSocket.OPEN;\n  }\n}\n\n// Export the dashboard WebSocket manager\n_DashboardWebSocketManager = DashboardWebSocketManager;\nDashboardWebSocketManager.instance = void 0;\nexport const dashboardWebSocket = DashboardWebSocketManager.getInstance();\n\n// Original useWebSocket hook for individual scans (keep your existing one)\nexport const useWebSocket = scanId => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [lastMessage, setLastMessage] = useState(null);\n  const [error, setError] = useState(null);\n  const wsRef = useRef(null);\n  const reconnectAttemptRef = useRef(0);\n  const maxReconnectAttempts = 5;\n  const connect = useCallback(() => {\n    var _wsRef$current;\n    if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) {\n      return;\n    }\n    try {\n      const ws = createWebSocket(scanId);\n      wsRef.current = ws;\n      ws.onopen = () => {\n        setIsConnected(true);\n        setError(null);\n        reconnectAttemptRef.current = 0;\n        console.log(`WebSocket connected for scan ${scanId}`);\n      };\n      ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          setLastMessage(data);\n          console.log(`Scan ${scanId} WebSocket message:`, data);\n\n          // If scan completes, trigger dashboard update\n          if (data.type === 'scan_completed') {\n            console.log(`Scan ${scanId} completed, notifying dashboard...`);\n            // Trigger dashboard refresh via the global manager\n            queryClient.invalidateQueries({\n              queryKey: ['dashboardMetrics']\n            });\n            queryClient.invalidateQueries({\n              queryKey: ['quickStats']\n            });\n            queryClient.invalidateQueries({\n              queryKey: ['reports']\n            });\n            setTimeout(() => {\n              queryClient.refetchQueries({\n                queryKey: ['dashboardMetrics']\n              });\n              queryClient.refetchQueries({\n                queryKey: ['quickStats']\n              });\n            }, 100);\n          }\n        } catch (err) {\n          console.error('Failed to parse WebSocket message:', err);\n        }\n      };\n      ws.onerror = error => {\n        console.error('WebSocket error:', error);\n        setError('WebSocket connection error');\n      };\n      ws.onclose = event => {\n        setIsConnected(false);\n        console.log(`WebSocket disconnected for scan ${scanId}:`, event.code, event.reason);\n\n        // Attempt reconnection\n        if (reconnectAttemptRef.current < maxReconnectAttempts) {\n          reconnectAttemptRef.current += 1;\n          const delay = Math.min(1000 * reconnectAttemptRef.current, 5000);\n          console.log(`Reconnecting scan ${scanId} in ${delay}ms...`);\n          setTimeout(() => {\n            if (scanId) {\n              connect();\n            }\n          }, delay);\n        }\n      };\n    } catch (err) {\n      setError('Failed to create WebSocket connection');\n      console.error('WebSocket creation error:', err);\n    }\n  }, [scanId]);\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n  }, []);\n  const sendMessage = useCallback(message => {\n    var _wsRef$current2;\n    if (((_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n      return true;\n    }\n    return false;\n  }, []);\n  useEffect(() => {\n    if (scanId) {\n      connect();\n    }\n    return () => {\n      disconnect();\n    };\n  }, [scanId, connect, disconnect]);\n  return {\n    isConnected,\n    lastMessage,\n    error,\n    sendMessage,\n    disconnect,\n    connect\n  };\n};\n\n// Hook for dashboard WebSocket\n_s(useWebSocket, \"pQ5pqTPT7T1BHFZD6LiqnxokIZY=\");\nexport const useDashboardWebSocket = () => {\n  _s2();\n  const [isConnected, setIsConnected] = useState(false);\n  const [lastMessage, setLastMessage] = useState(null);\n  useEffect(() => {\n    const handleConnected = () => {\n      setIsConnected(true);\n    };\n    const handleDisconnected = () => {\n      setIsConnected(false);\n    };\n    const handleMessage = message => {\n      setLastMessage(message);\n    };\n\n    // Subscribe to dashboard WebSocket events\n    dashboardWebSocket.on('connected', handleConnected);\n    dashboardWebSocket.on('disconnected', handleDisconnected);\n    dashboardWebSocket.on('message', handleMessage);\n\n    // Check initial connection state\n    setIsConnected(dashboardWebSocket.isConnected());\n    return () => {\n      dashboardWebSocket.off('connected', handleConnected);\n      dashboardWebSocket.off('disconnected', handleDisconnected);\n      dashboardWebSocket.off('message', handleMessage);\n    };\n  }, []);\n  return {\n    isConnected,\n    lastMessage,\n    dashboardWebSocket\n  };\n};\n_s2(useDashboardWebSocket, \"ucEp4sMgci7OMq1+/SroA9+n+Ec=\");","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","createWebSocket","queryClient","DashboardWebSocketManager","constructor","ws","listeners","Map","reconnectAttempts","maxReconnectAttempts","isConnecting","connect","getInstance","instance","protocol","window","location","host","hostname","url","console","log","WebSocket","onopen","notifyListeners","startHeartbeat","onmessage","event","message","JSON","parse","data","type","invalidateQueries","queryKey","setTimeout","refetchQueries","error","onclose","attemptReconnect","onerror","heartbeatInterval","setInterval","readyState","OPEN","send","stringify","clearInterval","delay","Math","min","pow","on","callback","has","set","get","push","off","index","indexOf","splice","forEach","getConnectionState","CLOSED","isConnected","_DashboardWebSocketManager","dashboardWebSocket","useWebSocket","scanId","_s","setIsConnected","lastMessage","setLastMessage","setError","wsRef","reconnectAttemptRef","_wsRef$current","current","err","code","reason","disconnect","close","sendMessage","_wsRef$current2","useDashboardWebSocket","_s2","handleConnected","handleDisconnected","handleMessage"],"sources":["D:/vuln-scanner/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\r\nimport { createWebSocket } from '../utils/api';\r\nimport { WebSocketMessage } from '../types';\r\nimport { queryClient } from '../utils/api';\r\n\r\n// Global WebSocket manager for dashboard\r\nclass DashboardWebSocketManager {\r\n  private static instance: DashboardWebSocketManager;\r\n  private ws: WebSocket | null = null;\r\n  private listeners: Map<string, Function[]> = new Map();\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private isConnecting = false;\r\n\r\n  private constructor() {\r\n    this.connect();\r\n  }\r\n\r\n  static getInstance(): DashboardWebSocketManager {\r\n    if (!DashboardWebSocketManager.instance) {\r\n      DashboardWebSocketManager.instance = new DashboardWebSocketManager();\r\n    }\r\n    return DashboardWebSocketManager.instance;\r\n  }\r\n\r\n  private connect() {\r\n    if (this.isConnecting) return;\r\n    \r\n    this.isConnecting = true;\r\n    \r\n    try {\r\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\r\n      const host = window.location.hostname === 'localhost' ? 'localhost:8000' : window.location.host;\r\n      const url = `${protocol}//${host}/api/scans/ws/dashboard`;\r\n      \r\n      console.log('Connecting to dashboard WebSocket:', url);\r\n      this.ws = new WebSocket(url);\r\n      \r\n      this.ws.onopen = () => {\r\n        console.log('Dashboard WebSocket connected');\r\n        this.isConnecting = false;\r\n        this.reconnectAttempts = 0;\r\n        this.notifyListeners('connected', null);\r\n        \r\n        // Start heartbeat\r\n        this.startHeartbeat();\r\n      };\r\n\r\n      this.ws.onmessage = (event) => {\r\n        try {\r\n          const message = JSON.parse(event.data);\r\n          console.log('Dashboard WebSocket message:', message);\r\n          \r\n          this.notifyListeners('message', message);\r\n          \r\n          // Handle specific events\r\n          if (message.type === 'dashboard_update') {\r\n            console.log('Dashboard update received, refreshing data...');\r\n            \r\n            // Invalidate all dashboard-related queries\r\n            queryClient.invalidateQueries({ queryKey: ['dashboardMetrics'] });\r\n            queryClient.invalidateQueries({ queryKey: ['quickStats'] });\r\n            queryClient.invalidateQueries({ queryKey: ['reports'] });\r\n            queryClient.invalidateQueries({ queryKey: ['scans'] });\r\n            \r\n            // Force refetch after a short delay\r\n            setTimeout(() => {\r\n              queryClient.refetchQueries({ queryKey: ['dashboardMetrics'] });\r\n              queryClient.refetchQueries({ queryKey: ['quickStats'] });\r\n            }, 100);\r\n            \r\n            this.notifyListeners('dashboardUpdate', message);\r\n          }\r\n          \r\n          if (message.type === 'scan_completed') {\r\n            console.log('Scan completed, updating dashboard...');\r\n            this.notifyListeners('scanCompleted', message);\r\n          }\r\n        } catch (error) {\r\n          console.error('Failed to parse dashboard WebSocket message:', error);\r\n        }\r\n      };\r\n\r\n      this.ws.onclose = () => {\r\n        console.log('Dashboard WebSocket disconnected');\r\n        this.isConnecting = false;\r\n        this.notifyListeners('disconnected', null);\r\n        this.attemptReconnect();\r\n      };\r\n\r\n      this.ws.onerror = (error) => {\r\n        console.error('Dashboard WebSocket error:', error);\r\n        this.isConnecting = false;\r\n        this.notifyListeners('error', error);\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to create dashboard WebSocket:', error);\r\n      this.isConnecting = false;\r\n      this.attemptReconnect();\r\n    }\r\n  }\r\n\r\n  private startHeartbeat() {\r\n    // Send ping every 30 seconds to keep connection alive\r\n    const heartbeatInterval = setInterval(() => {\r\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\r\n        this.ws.send(JSON.stringify({ type: 'ping' }));\r\n      } else {\r\n        clearInterval(heartbeatInterval);\r\n      }\r\n    }, 30000);\r\n  }\r\n\r\n  private attemptReconnect() {\r\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n      this.reconnectAttempts++;\r\n      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);\r\n      \r\n      console.log(`Attempting to reconnect dashboard WebSocket in ${delay}ms (attempt ${this.reconnectAttempts})`);\r\n      \r\n      setTimeout(() => {\r\n        if (!this.isConnecting) {\r\n          this.connect();\r\n        }\r\n      }, delay);\r\n    } else {\r\n      console.error('Max reconnection attempts reached for dashboard WebSocket');\r\n    }\r\n  }\r\n\r\n  on(event: string, callback: Function) {\r\n    if (!this.listeners.has(event)) {\r\n      this.listeners.set(event, []);\r\n    }\r\n    this.listeners.get(event)!.push(callback);\r\n  }\r\n\r\n  off(event: string, callback: Function) {\r\n    const listeners = this.listeners.get(event);\r\n    if (listeners) {\r\n      const index = listeners.indexOf(callback);\r\n      if (index > -1) {\r\n        listeners.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  private notifyListeners(event: string, data: any) {\r\n    const listeners = this.listeners.get(event);\r\n    if (listeners) {\r\n      // Use setTimeout to avoid React state updates during render\r\n      setTimeout(() => {\r\n        listeners.forEach(callback => {\r\n          try {\r\n            callback(data);\r\n          } catch (error) {\r\n            console.error('Error in dashboard WebSocket listener:', error);\r\n          }\r\n        });\r\n      }, 0);\r\n    }\r\n  }\r\n\r\n  send(message: any) {\r\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\r\n      this.ws.send(JSON.stringify(message));\r\n    }\r\n  }\r\n\r\n  getConnectionState() {\r\n    return this.ws ? this.ws.readyState : WebSocket.CLOSED;\r\n  }\r\n\r\n  isConnected() {\r\n    return this.ws && this.ws.readyState === WebSocket.OPEN;\r\n  }\r\n}\r\n\r\n// Export the dashboard WebSocket manager\r\nexport const dashboardWebSocket = DashboardWebSocketManager.getInstance();\r\n\r\n// Original useWebSocket hook for individual scans (keep your existing one)\r\nexport const useWebSocket = (scanId: string) => {\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [lastMessage, setLastMessage] = useState<WebSocketMessage | null>(null);\r\n  const [error, setError] = useState<string | null>(null);\r\n  \r\n  const wsRef = useRef<WebSocket | null>(null);\r\n  const reconnectAttemptRef = useRef(0);\r\n  const maxReconnectAttempts = 5;\r\n\r\n  const connect = useCallback(() => {\r\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const ws = createWebSocket(scanId);\r\n      wsRef.current = ws;\r\n\r\n      ws.onopen = () => {\r\n        setIsConnected(true);\r\n        setError(null);\r\n        reconnectAttemptRef.current = 0;\r\n        console.log(`WebSocket connected for scan ${scanId}`);\r\n      };\r\n\r\n      ws.onmessage = (event) => {\r\n        try {\r\n          const data: WebSocketMessage = JSON.parse(event.data);\r\n          setLastMessage(data);\r\n          console.log(`Scan ${scanId} WebSocket message:`, data);\r\n          \r\n          // If scan completes, trigger dashboard update\r\n          if (data.type === 'scan_completed') {\r\n            console.log(`Scan ${scanId} completed, notifying dashboard...`);\r\n            // Trigger dashboard refresh via the global manager\r\n            queryClient.invalidateQueries({ queryKey: ['dashboardMetrics'] });\r\n            queryClient.invalidateQueries({ queryKey: ['quickStats'] });\r\n            queryClient.invalidateQueries({ queryKey: ['reports'] });\r\n            \r\n            setTimeout(() => {\r\n              queryClient.refetchQueries({ queryKey: ['dashboardMetrics'] });\r\n              queryClient.refetchQueries({ queryKey: ['quickStats'] });\r\n            }, 100);\r\n          }\r\n        } catch (err) {\r\n          console.error('Failed to parse WebSocket message:', err);\r\n        }\r\n      };\r\n\r\n      ws.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n        setError('WebSocket connection error');\r\n      };\r\n\r\n      ws.onclose = (event) => {\r\n        setIsConnected(false);\r\n        console.log(`WebSocket disconnected for scan ${scanId}:`, event.code, event.reason);\r\n\r\n        // Attempt reconnection\r\n        if (reconnectAttemptRef.current < maxReconnectAttempts) {\r\n          reconnectAttemptRef.current += 1;\r\n          const delay = Math.min(1000 * reconnectAttemptRef.current, 5000);\r\n          \r\n          console.log(`Reconnecting scan ${scanId} in ${delay}ms...`);\r\n          setTimeout(() => {\r\n            if (scanId) {\r\n              connect();\r\n            }\r\n          }, delay);\r\n        }\r\n      };\r\n    } catch (err) {\r\n      setError('Failed to create WebSocket connection');\r\n      console.error('WebSocket creation error:', err);\r\n    }\r\n  }, [scanId]);\r\n\r\n  const disconnect = useCallback(() => {\r\n    if (wsRef.current) {\r\n      wsRef.current.close();\r\n      wsRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const sendMessage = useCallback((message: any) => {\r\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\r\n      wsRef.current.send(JSON.stringify(message));\r\n      return true;\r\n    }\r\n    return false;\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (scanId) {\r\n      connect();\r\n    }\r\n\r\n    return () => {\r\n      disconnect();\r\n    };\r\n  }, [scanId, connect, disconnect]);\r\n\r\n  return {\r\n    isConnected,\r\n    lastMessage,\r\n    error,\r\n    sendMessage,\r\n    disconnect,\r\n    connect,\r\n  };\r\n};\r\n\r\n// Hook for dashboard WebSocket\r\nexport const useDashboardWebSocket = () => {\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [lastMessage, setLastMessage] = useState<any>(null);\r\n\r\n  useEffect(() => {\r\n    const handleConnected = () => {\r\n      setIsConnected(true);\r\n    };\r\n\r\n    const handleDisconnected = () => {\r\n      setIsConnected(false);\r\n    };\r\n\r\n    const handleMessage = (message: any) => {\r\n      setLastMessage(message);\r\n    };\r\n\r\n    // Subscribe to dashboard WebSocket events\r\n    dashboardWebSocket.on('connected', handleConnected);\r\n    dashboardWebSocket.on('disconnected', handleDisconnected);\r\n    dashboardWebSocket.on('message', handleMessage);\r\n\r\n    // Check initial connection state\r\n    setIsConnected(dashboardWebSocket.isConnected());\r\n\r\n    return () => {\r\n      dashboardWebSocket.off('connected', handleConnected);\r\n      dashboardWebSocket.off('disconnected', handleDisconnected);\r\n      dashboardWebSocket.off('message', handleMessage);\r\n    };\r\n  }, []);\r\n\r\n  return {\r\n    isConnected,\r\n    lastMessage,\r\n    dashboardWebSocket,\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}